{
	"boilerplate": {
		"prefix": "boilerplate",
		"body": [
			"#include <bits/stdc++.h>",
			"",
			"#define MOD 1000000007",
			"//#define MOD 998244353",
			"#define infinity numeric_limits<int>::max()",
			"",
			"#define int long long int",
			"#define double long double",
			"#define pii pair<int, int>",
			"",
			"#define endl '\\n'",
			"",
			"using namespace std;",
			"",
			"template <typename T>",
			"void print_arr(vector<T> &arr) {",
			"    for (T element : arr) {",
			"        cout << element << ' ';",
			"    }",
			"    cout << endl;",
			"}",
			"",
			"template <typename T>",
			"void sort_arr(vector<T> &arr) {",
			"    sort(arr.begin(), arr.end());",
			"}",
			"",
			"void solve_testcase() {",
			"    int n;",
			"    cin >> n;",
			"    vector<int> arr(n);",
			"    for (int i = 0; i < n; i++) {",
			"        cin >> arr[i];",
			"    }",
			"}",
			"",
			"int32_t main() {",
			"    ios_base::sync_with_stdio(false);",
			"    cin.tie(NULL);",
			"",
			"    int t;",
			"    cin >> t;",
			"    while (t--) {",
			"        solve_testcase();",
			"    }",
			"}"
		],
		"description": "boilerplate"
	},
	"count inversions in an array": {
		"prefix": "countinversions",
		"body": [
			"int merge(vector<int> &arr, int i, int j, vector<int> &temp_merge) {",
			"    int mid = (i + j) / 2;",
			"    int p = i;",
			"    int i2 = i, j2 = mid + 1;",
			"",
			"    int ans = 0;",
			"    while (i2 <= mid && j2 <= j) {",
			"        if (arr[i2] <= arr[j2]) {",
			"            temp_merge[p] = arr[i2];",
			"            i2++;",
			"        } else {",
			"            temp_merge[p] = arr[j2];",
			"            j2++;",
			"            ans += (mid + 1 - i2);",
			"        }",
			"        p++;",
			"    }",
			"    while (i2 <= mid) {",
			"        temp_merge[p] = arr[i2];",
			"        i2++;",
			"        p++;",
			"    }",
			"    while (j2 <= j) {",
			"        temp_merge[p] = arr[j2];",
			"        j2++;",
			"        p++;",
			"    }",
			"",
			"    for (int index = i; index <= j; index++) {",
			"        arr[index] = temp_merge[index];",
			"    }",
			"",
			"    return ans;",
			"}",
			"",
			"int merge_sort(vector<int> &arr, int i, int j, vector<int> &temp_merge) {",
			"    int ans = 0;",
			"",
			"    if (i < j) {",
			"        int mid = (i + j) / 2;",
			"",
			"        ans += merge_sort(arr, i, mid, temp_merge);",
			"        ans += merge_sort(arr, mid + 1, j, temp_merge);",
			"        ans += merge(arr, i, j, temp_merge);",
			"    }",
			"",
			"    return ans;",
			"}",
			"",
			"int countInversions(vector<int> &arr) {",
			"    int n = arr.size();",
			"",
			"    vector<int> temp_merge(n);",
			"    return merge_sort(arr, 0, n - 1, temp_merge);",
			"}"
		],
		"description": "count inversions in an array"
	},
	"generate a dsu class": {
		"prefix": "dsu",
		"body": [
			"class DSU {",
			"   private:",
			"    int n;",
			"    vector<int> parent;",
			"    vector<int> size;",
			"",
			"   public:",
			"    DSU(int n1) {",
			"        n = n1;",
			"        parent = vector<int>(n);",
			"        size = vector<int>(n);",
			"    }",
			"",
			"    void make(int v) {",
			"        parent[v] = v;",
			"        size[v] = 1;",
			"    }",
			"",
			"    int find(int v) {",
			"        if (v == parent[v]) {",
			"            return v;",
			"        }",
			"",
			"        // path compression",
			"        return parent[v] = find(parent[v]);",
			"    }",
			"",
			"    // union",
			"    void unn(int u, int v) {",
			"        int a = find(u);",
			"        int b = find(v);",
			"",
			"        if (a != b) {",
			"            // union by size",
			"            if (size[a] < size[b]) {",
			"                swap(a, b);",
			"            }",
			"",
			"            parent[b] = a;",
			"            size[a] += size[b];",
			"        }",
			"    }",
			"};"
		],
		"description": "generate a dsu class"
	},
	"seive of eratothenes": {
		"prefix": "seive",
		"body": [
			"vector<bool> seive(int n)",
			"{",
			"    vector<bool> is_prime(n + 1, true);",
			"    is_prime[0] = is_prime[1] = false;",
			"",
			"    for (int p = 2; p * p <= n; p++)",
			"    {",
			"        if (is_prime[p])",
			"        {",
			"            for (int i = p * p; i <= n; i += p)",
			"                is_prime[i] = false;",
			"        }",
			"    }",
			"",
			"    return is_prime;",
			"}"
		],
		"description": "seive of eratothenes"
	},
	"prime factors": {
		"prefix": "primefactors",
		"body": [
			"vector<int> prime_factors(int n) {",
			"    vector<int> ans;",
			"    while (n % 2 == 0) {",
			"        ans.push_back(2);",
			"        n /= 2;",
			"    }",
			"",
			"    for (int i = 3; i <= sqrt(n); i += 2) {",
			"        if (n % i == 0) {",
			"            ans.push_back(i);",
			"            n /= i;",
			"        }",
			"    }",
			"",
			"    if (n > 2) {",
			"        ans.push_back(n);",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "prime factors"
	},
	"factors": {
		"prefix": "factors",
		"body": [
			"vector<int> factors(int n) {",
			"    vector<int> ans;",
			"",
			"    for (int i = 1; i <= sqrt(n); i++) {",
			"        if (n % i == 0) {",
			"            ans.push_back(i);",
			"            if (i != n / i) ans.push_back(n / i);",
			"        }",
			"    }",
			"",
			"    return ans;",
			"}"
		],
		"description": "factors"
	},
	"print yes": {
		"prefix": "yes",
		"body": [
			"cout << \"YES\" << endl;"
		],
		"description": "print yes"
	},
	"print no": {
		"prefix": "no",
		"body": [
			"cout << \"NO\" << endl;"
		],
		"description": "print no"
	}
}